\documentclass[a4paper]{article}
\usepackage{latexsym}
\usepackage[a4paper]{geometry}
\usepackage{color}
\usepackage{listings}
\usepackage[pdftex]{graphicx}
\usepackage{subfig}

\definecolor{Blue}{rgb}{0,0,0.5}
\definecolor{Green}{rgb}{0,0.75,0.0}
\definecolor{LightGray}{rgb}{0.6,0.6,0.6}
\definecolor{DarkGray}{rgb}{0.3,0.3,0.3}
\definecolor{gray}{rgb}{0.45,0.45,0.45}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{%
\parbox{\textwidth}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}\vskip-4pt}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

\lstset{language=C++,
%   keywords={function,uint8,uint16,uint32,double,break,case,catch,continue,else,elseif,end,for,global,if,otherwise,persistent,return,switch,try,while},
   basicstyle=\ttfamily\small,
%   breaklines=true,
   keywordstyle=\bfseries,
   commentstyle=\itshape\color{LightGray},
   stringstyle=\itshape\color{DarkGray},
%   numbers=left,
%   numberstyle=\tiny\color{DarkGray},
%   stepnumber=1,
%   numbersep=10pt,
   backgroundcolor=\color{white},
%   tabsize=2,
   showspaces=false,
   showstringspaces=false,
   captionpos=t,
   frame=lrb,
   xleftmargin=\fboxsep,
   xrightmargin=-\fboxsep,
   %belowcaptionskip=1em
   }

%Boldface text for type writer font
\usepackage{bold-extra} %\DeclareFontShape{OT1}{cmtt}{bx}{n}{<5><6><7><8><9><10><10.95><12><14.4><17.28><20.74><24.88>cmttb10}{}

%Break words properly at the end of a line (which isn't sloppy...)
\sloppy

%Use command \exercise for each exercise
\newcounter{exerciseCount}
\setcounter{exerciseCount}{8}
\newcommand{\exercise}[1]{\addtocounter{exerciseCount}{1} \noindent \medskip {\large \textsf{\textbf{Exercise \arabic{exerciseCount} #1}}} \par}
\renewcommand{\theenumi}{\textsf{\textbf{\alph{enumi}}}}

%Use command \code for code snippets
\newcommand{\code}[1]{\textnormal{\texttt{#1}}}

\setlength{\parindent}{0in}

\title{\textsf{C/C++ Part I \\ Chapter 2 - Set Two}}
\author{Christian Manteuffel \and Spyros Ioakeimidis}
\date{\today}

\begin{document}
\maketitle

\exercise{}
%spyros

\lstinputlisting[caption=ex9.cc]{./src/ex9/ex9.cc}

When we assign 100 to the variable \verb|value| the character `d' is shown. This because the decimal number 100 corresponds to the character `d' in the ascii table. The type \verb|size_t| is 8 bytes and the type \verb|char| is 1 byte. So when the variable \verb|value| with 356 is casted from \verb|size_t| to \verb|char|, it results to a variable with the size of 1 byte.

The byte that is left has the binary form of \verb|01100100| which is equal to 100 and hence it shows the same character `d', because as we previously mentioned the decimal value 100 corresponds to the character `d' in the ascii table.\\

The unsigned value of 200 is shown using the variable \verb|value|. In the first case we have chosen to cast the variable \verb|value| to the type \verb|char|, because we knew that this conversion would give us directly the character. Although, we were aware that this conversion would lead to loss of data, this was not an issue in this case. The \verb|char| type has sufficient size in order to correspond to every character from the ascii table.

In the second case, we casted the variable \verb|ch| to \verb|size_t|. We used this cast because we knew that this would give us back the number that corresponds to the character `d'. We could have used a cast to \verb|unsigned int|, however we preferred to use \verb|size_t| instead, as it is also proposed in the C++ Annotations.\\

\exercise{}
%manni
% Purpose of this exercise: understand how the compiler reads source files and understand how the decrement operators work.
% Consider the following expressions (make sure you realize the correct number of minuses, hence the top line indicating column numbers):
% 
% 
%             123456
%     1:      ----a
%     2:      -----a
%     3:      a----
%         
% Why does the first expression compile?
% Why does the second expression not compile?
% Why does the third expression not compile?
% Change the a in the first expression into the value 5 and explain why the thus changed expression does not compile.
% Change the layout of the second expression showing the way the compiler interprets that expression: add blanks to show what different elements the compiler sees.
% Provide two different layouts for the second expression which would result in completely different (but compilable) interpretations of the expression.
% When changing the layout, do not use parentheses but only blanks.

\begin{description}
    \item[a)]\- 
    	\verb|----a|
    \item[b)]\- 
    	\verb|-----a| results in the error \texttt{lvalue required as decrement operand}. The compiler first applies the \verb|-| prefix operator to a, which turns the a into an rvalue. The \verb|--| decrement operators can only operate on a lvalue.
    \item[c)]\- 
	    \verb|a----| results in the error \texttt{lvalue required as decrement operand}
    \item[d)]\- 
    	\verb|----5| results in the error \texttt{lvalue required as decrement operand}
    \item[e)] Change the layout of the second expression showing the way the compiler interprets that expression: add blanks to show what different elements the compiler sees.\\
    	\verb|-- -- -a|
    
    
    \item[f)]\-
     Provide two different layouts for the second expression which would result in completely different (but compilable) interpretations of the expression.\\
	\verb|- ----a| results in two decrements and turns the result negative e.g. if a is initialy 5, after the operation it will be -3.
    
\end{description}

\exercise{}
%spyros

\lstinputlisting[caption=programename.cc]{./src/ex11/ex11.cc}

\exercise{}
\lstinputlisting[caption=line.cc,label=lst:line]{src/ex12/line.cc}
\begin{description}
%mann
% Purpose of this exercise: understand the way getline() operates.
% The function getline(std::istream &in, std::string &str) is frequently used to read the next line from an istream, storing the line in the std::string str.
% Design a program that extracts a line from the standard input and inserts the text `incomplete line' into the standard output stream if the line did not terminate with a \n-character and inserts the text `complete line' into the standard output stream if the line did terminate with a \n-character.
% If the program is called line, use /bin/echo -n hello world | line to read an incomplete line, use /bin/echo hello world | line to read a complete line.
% This program should contain only one statement, starting with cout.

% In the C standard library there lives a function gets which can also be used to read a line of text from the input stream. The function gets fills a buffer of type char *. For now assume that these kinds of buffers exist, are comparable to std::string objects, and that you have a buffer of type char *. Would you use gets to fill that buffer? Explain your answer.
\item[b) Would you use gets to fill that buffer?]\-

Many problems in C programs are caused by buffer overruns, boundary errors and allocation problems that can be traced back to improperly using these traditional C string library functions

C++ strings handle all the required memory management and thus memory related problems, which is the \#1 source of problems in C programs, can be prevented when C++ strings are used.
% 
% Suggestion: insert the line `using namespace std;' just beyond the last #include directive to prevent you from having to write std:: many times.
\end{description}
\exercise{}
%spyros

\begin{itemize}
	\item \verb|~ a ^ 012 & x << 4|
	
	\begin{verbatim}
	|--                 1
	            --|---  2
	      ----|-------  3
	----|-------------  4
	\end{verbatim}
	\item \verb|x += y = 4 == a|
	\item \verb|a == b == c|
\end{itemize}

\exercise{}
% manni (optional)
A number is an exact power of two, if and only if the binary representation contains exactly one 1 since each digit represents an increasing power of 2, e.g. 4 = 0x0100. This can be used to check for the power of two using the binary and operator (\verb|&|).
The result of the (\verb|&|)-operator between the value and the value-1 will only result in 0, if value is a power of two. In all other cases the result will contain at least two 1's (or zero).


The code shown in Listing~\ref{lst:powerOfTwo} first checks if the value is not 0 and if this is not the case, uses the perviously discussed operation to determine whether a number is an exact power of two. 

\lstinputlisting[caption=powerOfTwo.cc,label=lst:powerOfTwo]{src/ex14/powerOfTwo.cc}

\exercise{}
%spyros

\end{document}
